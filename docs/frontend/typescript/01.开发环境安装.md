---
title: 二、更多扩展
---

## 一.泛型

泛型就是解决类、接口等方法的复用性问题,以及对不特定数据的支持问题的类型

泛型 -- 语法 -- 名字<T1,  T2, ……>

泛型为 函数、接口、类 定义类型变量

```js
function fn (arg: any) : any{ return arg }
function fn (arg: string | number) : string | number{ return arg }

function fn<T> (arg: T) : T{
	return arg 
}
fn<number>(123)

function fn<T, U> (arg: [T, U]) : [U, T]{
	return [arg[1], arg[0]] 
}
fn<number, string>([123, ‘xxx’])
```
T/U是占位符，用来指定任意输入的类型。。不要试图假设T/U的类型


### 1.泛型函数
```js
function fn (arg: number) : number {
function fn<T> (arg: T) : T {
	return arg
} 
let fn : (arg: number) => number = function (arg: number) : number {
let fn : <T>(arg: T) => T = function (arg: T) : T {
	 return arg
}

console.log( fn(18) )
console.log( fn<number>(18) )
```

### 2.泛型接口
```js
interface Fn {
	(arg: number) : number
	<T>(arg: T) : T
}
let fn: Fn = (arg: number) => number { …… }
let fn: Fn = <T>(arg: T) => T { …… }

console.log(fn(18))
console.log(fn<number>(18))
```

```js
interface Fn<T> {
	height (arg: T) : T;
	age: T
}
let fn: Fn<number> = (arg) => { …… }
let fn: Fn<number> = { …}

console.log(fn(18))
console.log(fn.height(18))

```

### 3.泛型类
```js
class Fanclass <T> {
	val: T;
	static name:T = 22
	constructor（ val : T）{ 
		this. val = val
	}
	add( x: T):T{return x}
	add: (x: T) => T
	add: (x:T) => T = function (x:T):T{
		 return x
	}      
}
let myClass = new Xiaojiejie<number>(22)
myClass.add(12)

```
类的静态部分,不能使用这个类型参数。抽象方法可以，

### 4.泛型数组

```js
// 写法 - Array<T>
Let arr : number[] = [1, 23, 5]

Let arr : Array<number> = [1, 23, 5]

// 只读数组
Let arr : ReadonlyArray<number> = [1, 23, 5]
arr[0] = 123
```

### 5.泛型约束

简单的理解，约束参数类型的必须拥有某个属性或者方法
```js
function fn<T> (arg: T) : T {
	console.log(arg.length)
	return arg
} 
fn<number>(123)

```

```js
interface Length {
	length: number
}
function fn<T extends Length> (arg: T) : T {
	console.log(arg.length)
	return arg
} 
fn (123)
fn (`abc`)
fn({length: 3, ……})

```

关键字extends, 实际上与继承同义，类型变量继承被约束类型的所有成员

多个类型参数之间也可以互相约束：
```js

function fn<T extends U, U>(a: T, b: U): T {
for (let key in b) {
	a[key] = (<T>b)[key];
}
return a;
}
let a = { a: 1, b: 2, c: 3, d: 4 };
fn(a, { b: 10, d: 20 });

```
泛型 -- 默认类型

```js
interface Length<T> {
	length: T
}
let a:length<string> = {
	length:  `wwwww`
}

interface Length<T = string> {
	length: T
}
let a:length= {
	length:  `wwwww`
}

```


类型别名

类型别名用来给一个类型起个新名字, 关键字 type

```js
type newName = T1  | T2 | ……

// string 类型别名
type myString = string

//  函数类型别名
type myFn = () => number

//  联合类型别名
type myLianhe = myString | myFn 

```


## 二.TS的装饰器

- 它是一个表达式 -> 被执行后 -> 返回一个函数
- 它是一种特殊类型的声明 -> 它能够被附加到类声明,方法,属性或参数上,可以修改类的行为

### 1.类装饰器

接收一个参数-被装饰的类
```js
function Greeter(greeting: string) {
  return function(target: Function) {
    target.prototype.greet = function(): void {
      console.log(greeting)
    }
  }
}

@Greeter("Hello TS!")
class Greeting {
  constructor() {
    // 内部实现
  }
}

let myGreeting: any = new Greeting()
myGreeting.greet()  //Hello TS!
```

### 2.属性装饰器

接收两个参数- 被装饰的类target 和 类的属性名attr

```js
function logProperty(value: string) {
  return function (target: any, attr: string) {
    //target-成员对象,attr-属性
    console.log(target)
    console.log(attr)
    //可以通过修饰器改变属性的值
    target[attr] = value 
  }
}

class HttpClient {
 //修饰器后面紧跟着对应要修饰的属性
  @logProperty('hello world') 
  public url: string | undefined
  constructor() {}
  getData() {
    console.log(this.url)
  }
}

let http: any = new HttpClient()
http.getData() //hello world
```

### 3.方法装饰器

接收三个参数- 被装饰的类target 和 方法名propertyKey 和 属性描述符descriptor

```js
function log(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
    let originalMethod = descriptor.value;
    descriptor.value = function (...args: any[]) {
        console.log("wrapped function: before invoking " + propertyKey);
        let result = originalMethod.apply(this, args);
        console.log("wrapped function: after invoking " + propertyKey);
        return result;
    };
}

class Task {
    @log
    runTask(arg: any): any {
        console.log("runTask invoked, args: " + arg);
        return "finished";
    }
}

let task = new Task();
let result = task.runTask("learn ts");
console.log("result: " + result);
```

### 4.参数装饰器

接收三个参数- 被装饰的类target 和 方法名key 和 方法中参数的索引值parameterIndex
```js
function Log(target: Function, key: string, parameterIndex: number) {
  let functionLogged = key || target.prototype.constructor.name;
  console.log(`The parameter in position ${parameterIndex} at ${functionLogged} has
	been decorated`);
}

class Greeter {
  greeting: string;
  constructor(@Log phrase: string) {
	this.greeting = phrase; 
  }
}
```

**待办任务：**

xiaoman的ts

8-class和9-抽象类
14-symbol类型和15-迭代器和生成器
26-实战TS编写发布订阅模式
27-TS进阶用法proxy & Reflect
28-TS进阶用法Partial & Pick
29-TS进阶用法Record & Readonly
30-TS进阶用法infer
31-infer 类型提取
32-infer 递归

15+20 待整理

https://xiaoman.blog.csdn.net/article/details/122525099


类型保护与区分类型
字面量类型
可辨识联合
this类型
索引类型
映射类型

## 参考

1. [深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/project/compilationContext.html#tsconfig-json)
2. [来玩 TypeScript 啊，机都给你开好了！](https://www.zhihu.com/column/c_206498766)
