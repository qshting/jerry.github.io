---
title: 二、更多扩展
---

## 一.泛型

泛型就是动态类型，解决类、接口等方法的复用性问题,以及对不特定数据的支持问题的类型

泛型语法 -- 名字<T1,  T2, ……>

泛型为 函数、接口、类 定义类型变量

```js
function fn (arg: any) : any{ return arg }
function fn (arg: string | number) : string | number{ return arg }

// 泛型优化的写法
function fn<T> (arg: T) : T{
	return arg 
}
fn<number>(123)

// 泛型多参数的写法
function fn<T, U> (arg: [T, U]) : [U, T]{
	return [arg[1], arg[0]] 
}
fn<number, string>([123, ‘xxx’])
```
T/U是占位符，用来指定任意输入的类型。。不要试图假设T/U的类型


### 1.泛型函数
```js
let fn : (arg: number) => number = function (arg: number) : number {
    return arg
}
let fn : <T>(arg: T) => T = function (arg: T) : T {
	 return arg
}

console.log( fn(18) )
console.log( fn<number>(18) )
```

### 2.泛型接口

接口名字<参数>，使用的时候传递类型
```js
interface MyInter<T> {
    (arg: T): T
}

function fn<T>(arg: T): T {
    return arg
}

let result: MyInter<number> = fn
result(123)
```

### 3.泛型类
```js
class Fanclass <T> {
	val: T;
	static name:T = 22
	constructor（ val : T）{ 
		this. val = val
	}
	add( x: T):T{return x}
	add: (x: T) => T
	add: (x:T) => T = function (x:T):T{
		 return x
	}      
}
let myClass = new Xiaojiejie<number>(22)
myClass.add(12)

```
类的静态部分,不能使用这个类型参数。抽象方法可以，

### 4.泛型数组

```js
// 写法 - Array<T>
Let arr : number[] = [1, 23, 5]

Let arr : Array<number> = [1, 23, 5]

// 只读数组
Let arr : ReadonlyArray<number> = [1, 23, 5]
arr[0] = 123
```

### 5.泛型约束

简单的理解，约束参数类型的必须拥有某个属性或者方法
```js
function fn<T> (arg: T) : T {
	console.log(arg.length)
	return arg
} 
fn<number>(123)

```

```js
interface Length {
	length: number
}
function fn<T extends Length> (arg: T) : T {
	console.log(arg.length)
	return arg
} 
fn (123)
fn (`abc`)
fn({length: 3, ……})

```

关键字extends, 实际上与继承同义，类型变量继承被约束类型的所有成员

多个类型参数之间也可以互相约束：
```js

function fn<T extends U, U>(a: T, b: U): T {
for (let key in b) {
	a[key] = (<T>b)[key];
}
return a;
}
let a = { a: 1, b: 2, c: 3, d: 4 };
fn(a, { b: 10, d: 20 });

```
泛型 -- 默认类型

```js
interface Length<T> {
	length: T
}
let a:length<string> = {
	length:  `wwwww`
}

interface Length<T = string> {
	length: T
}
let a:length= {
	length:  `wwwww`
}

```


类型别名

类型别名用来给一个类型起个新名字, 关键字 type

```js
type newName = T1  | T2 | ……

// string 类型别名
type myString = string

//  函数类型别名
type myFn = () => number

//  联合类型别名
type myLianhe = myString | myFn 

```


## 二.TS的装饰器

- 它是一个表达式 -> 被执行后 -> 返回一个函数
- 它是一种特殊类型的声明 -> 它能够被附加到类声明,方法,属性或参数上,可以修改类的行为

### 1.类装饰器

接收一个参数-被装饰的类
```js
function Greeter(greeting: string) {
  return function(target: Function) {
    target.prototype.greet = function(): void {
      console.log(greeting)
    }
  }
}

@Greeter("Hello TS!")
class Greeting {
  constructor() {
    // 内部实现
  }
}

let myGreeting: any = new Greeting()
myGreeting.greet()  //Hello TS!
```

### 2.属性装饰器

接收两个参数- 被装饰的类target 和 类的属性名attr

```js
function logProperty(value: string) {
  return function (target: any, attr: string) {
    //target-成员对象,attr-属性
    console.log(target)
    console.log(attr)
    //可以通过修饰器改变属性的值
    target[attr] = value 
  }
}

class HttpClient {
 //修饰器后面紧跟着对应要修饰的属性
  @logProperty('hello world') 
  public url: string | undefined
  constructor() {}
  getData() {
    console.log(this.url)
  }
}

let http: any = new HttpClient()
http.getData() //hello world
```

### 3.方法装饰器

接收三个参数- 被装饰的类target 和 方法名propertyKey 和 属性描述符descriptor

```js
function log(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
    let originalMethod = descriptor.value;
    descriptor.value = function (...args: any[]) {
        console.log("wrapped function: before invoking " + propertyKey);
        let result = originalMethod.apply(this, args);
        console.log("wrapped function: after invoking " + propertyKey);
        return result;
    };
}

class Task {
    @log
    runTask(arg: any): any {
        console.log("runTask invoked, args: " + arg);
        return "finished";
    }
}

let task = new Task();
let result = task.runTask("learn ts");
console.log("result: " + result);
```

### 4.参数装饰器

接收三个参数- 被装饰的类target 和 方法名key 和 方法中参数的索引值parameterIndex
```js
function Log(target: Function, key: string, parameterIndex: number) {
  let functionLogged = key || target.prototype.constructor.name;
  console.log(`The parameter in position ${parameterIndex} at ${functionLogged} has
	been decorated`);
}

class Greeter {
  greeting: string;
  constructor(@Log phrase: string) {
	this.greeting = phrase; 
  }
}
```

## 三.接口

- 接口（Interface）可以描述函数、对象、构造器的结构
- 对传入参数进行约束
- 对类里面的属性、方法进行声明约束，实现这个接口的类必须实现接口里面的属性和方法

```js
// 声明接口
interface TypeA {
	...
}

// 声明a为TypeA类型并赋值
let a: TypeA = { … }
```

- 可选属性 ?
- 只读属性 readonly
- 任意属性 [propName: string]: any

```js
interface Person {
    name: string;
    age?: number;
    readonly x: number;
    [propName: string]: any;
}
```

##### 1.属性类型接口

用作对json对象的约束，或者对象类型的声明

```js
// 例1：封装ajax请求(必须传入type和url)
interface Config {
  type: string
  url: string
  data?: string
  dataType?: string
}

function ajax(config: Config) {
  let xhr: XMLHttpRequest = new XMLHttpRequest()
  xhr.open(config.type, config.url, true)
  xhr.send(config.data)

  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4 && xhr.status === 20) {
        ...
    }
  }
}

ajax({
  type: 'get',
  url: 'http://www.baidu.com/',
  data: 'name=张三'
})

```

```js
// 例2： 用接口来描述和后台服务的api
interface List {
    readonly id: number;
    name: string;
    // [x: string]: any;
    age?: number;
}
interface Result {
    data: List[]
}
function render(result: Result) {
    result.data.forEach((value) => {
        console.log(value.id, value.name)
        if (value.age) {
            console.log(value.age)
        }
    })
}
let result = {
    data: [
        {id: 1, name: 'A', sex: 'male'},
        {id: 2, name: 'B', age: 10}
    ]
}
render(result)
```


##### 2.函数类型接口

给接口定义一个调用签名，用于对方法传入的参数和返回值进行约束
```js
//加密的函数类型接口
interface encrypt {
  (key: string, value: string): string
  a: string
}

let md5: encrypt = function (key: string, value: string): string {
  return key + '---' + value
}
// 函数必须是两个参数,同时返回值必须是接口的返回值string

console.log(md5('name', '张三'))

```


```js
// 函数定义 - 4种方式

// 01 - 函数型
function add1(x: number, y: number) {
    return x + y
}

// 02 - 用变量
let add2: (x: number, y: number) => number

// 03 - 用接口
interface Add3 {
    (x: number, y: number): number
}

// 04 - 用类型别名
type Add4 = (x: number, y: number) => number
let add: Add4 = (a, b => a + b

```

##### 3.可索引接口

(用作对数组和对象进行约束 - 不常用)
```js
//对数组使用
interface Arr {
  [index: number]: string
}

//对对象使用
interface Obj {
  [index: string]: string
}
```

```js
例1：不确定接口个数时,使用可索引接口定义
// 数字可索引
interface StringArray {
    [index: number]: string
}
let chars: StringArray = ['a', 'b']

// 字符串可索引
interface Names {
    [x: string]: any;
    // y: number;
    [z: number]: number;
}
```

##### 4. 类类型接口

实现（implements）

一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些公有的特性，这时候可以吧特性提取成接口，用implements关键字实现
```js
interface Watch{
	watch():string
} 
class Tv implements Watch {
	watch() { …… }
}
class Phone implements Watch {
	watch() { …… }
}

```

```js
interface Other{
	call()；
	play();
} 
class Phone implements Watch, Other {
	private watch() { …… }
	call() { …… }
	play() { …… }
}

```
一个类可以实现多个接口，但只能extends自一个类（接口用于对类的一部分行为的抽象，不包括具体的实现）接口只能描述类的公共（public）部分


1)  实例类类型接口(只会对实例的属性进行限制,方法也是类的属性. 接口描述了类的公共部分)
```js
//因为eat也可以说是一个属性
interface Animal {
  name: string
  eat(str: string): void
}

class Dog implements Animal {
  private age: number = 2 
  //接口来限制类(类中必须有name属性和eat方法)
  //类中也可以有其他的属性
  constructor(public name: string) {}
  eat(str: string) {
    console.log(this.name + '吃' + str)
  }
}
let dog: Dog = new Dog('狗')
dog.eat('狗粮')
```

2)  构造器与静态类接口
```js
// 定义了两个接口, ClockConstructor为构造函数所用, ClockInterface为实例方法所用
// 定义一个构造函数 createClock，它用传入的类型创建实例

interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface
}
interface ClockInterface {
    tick()
}

function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("beep beep")
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log("tick tock")
    }
}

let digital = createClock(DigitalClock, 12, 17)
let analog = createClock(AnalogClock, 7, 32)

```

##### 5. 混合类型接口
```js
//这个混合类型限制的变量本身是个函数,但是有reset方法和interval属性
interface Counter {
  (start: number): number
  interval: number
  reset(): void
}

function getCounter(): Counter {
  let counter: Counter = function (start: number): number {
    return start++
  } as Counter
  counter.interval = 123

  counter.reset = function () {
    this.interval = 0
  }
  return counter
}

let c = getCounter()
c(10)
c.reset()
console.log(c.interval)
```


```js
// 混合类型接口 -- 单例模式
interface Lib {
    (): void;
    version: string;
    doSomething(): void;
}
let lib = (() => {}) as Lib
lib.version = '1.0.0'
lib.doSomething = () => {}
```

```js
// 混合类型接口 -- 多例模式
interface Lib {
    (): void;
    version: string;
    doSomething(): void;
}
function getLib() {
    let lib = (() => {}) as Lib
    lib.version = '1.0.0'
    lib.doSomething = () => {}
    return lib;
}
let lib1 = getLib()
lib1()
let lib2 = getLib()
lib2.doSomething()
```


##### 6. 接口扩展 - extends

可以用子接口扩展父接口,从而拿到多个接口的限制条件(类似于类的继承)

```js
interface Animal {
  eat(): void
}

interface Person extends Animal {
  name: string
  work(): void
}

class Student implements Person {
  constructor(public name: string) {}
  eat() {
    console.log(this.name + '吃饭')
  }
  work() {
    console.log(this.name + '上学')
  }
}

//接口会同时将前面两者的接口限制合并
```

##### 7. 继承类类型接口

类可以当作接口来使用,也可以被接口所继承
```js
class Control {
  private state: any
}

interface SelectableControl extends Control {
  select(): void
}

class Button extends Control implements SelectableControl {
  select(): void {}
}

class Radio extends Control {
  select(): void {}
}
```

## 参考

**待办任务：**

- 小满zs的TypeScript
- 8-class和9-抽象类
- 14-symbol类型和15-迭代器和生成器
- 20-装饰器Decorator
- 21-Rollup构建TS项目 & webpack构建TS项目
- 26-实战TS编写发布订阅模式 27-TS进阶用法proxy & Reflect 28-TS进阶用法Partial & Pick 29-TS进阶用法Record & Readonly 30-TS进阶用法infer 31-infer 类型提取 32-infer 递归

类型保护与区分类型
字面量类型
可辨识联合
this类型
索引类型
映射类型



1. [xiaoman的TypeScript](https://blog.csdn.net/qq1195566313/category_11559497.html)
2. [深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/project/compilationContext.html#tsconfig-json)
3. [来玩 TypeScript 啊，机都给你开好了！](https://www.zhihu.com/column/c_206498766)

知识查询：
1. [TypeScript入门教程](ts.xcatliu.com/)
2. [博客- 一份不可多得的 TS 学习指南](https://juejin.cn/post/6872111128135073806)
3. [TypeScript 知识汇总](https://juejin.cn/post/6844903709172826119)
4. [技术胖的 TypeScript免费视频图文教程](https://juejin.cn/post/6876240277208563720)