---
title: 二、更多扩展
---

## 一.TS的装饰器

- 它是一个表达式 -> 被执行后 -> 返回一个函数
- 它是一种特殊类型的声明 -> 它能够被附加到类声明,方法,属性或参数上,可以修改类的行为

### 1.类装饰器

接收一个参数-被装饰的类
```js
function Greeter(greeting: string) {
  return function(target: Function) {
    target.prototype.greet = function(): void {
      console.log(greeting)
    }
  }
}

@Greeter("Hello TS!")
class Greeting {
  constructor() {
    // 内部实现
  }
}

let myGreeting: any = new Greeting()
myGreeting.greet()  //Hello TS!
```

### 2.属性装饰器

接收两个参数- 被装饰的类target 和 类的属性名attr

```js
function logProperty(value: string) {
  return function (target: any, attr: string) {
    //target-成员对象,attr-属性
    console.log(target)
    console.log(attr)
    //可以通过修饰器改变属性的值
    target[attr] = value 
  }
}

class HttpClient {
 //修饰器后面紧跟着对应要修饰的属性
  @logProperty('hello world') 
  public url: string | undefined
  constructor() {}
  getData() {
    console.log(this.url)
  }
}

let http: any = new HttpClient()
http.getData() //hello world
```

### 3.方法装饰器

接收三个参数- 被装饰的类target 和 方法名propertyKey 和 属性描述符descriptor

```js
function log(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
    let originalMethod = descriptor.value;
    descriptor.value = function (...args: any[]) {
        console.log("wrapped function: before invoking " + propertyKey);
        let result = originalMethod.apply(this, args);
        console.log("wrapped function: after invoking " + propertyKey);
        return result;
    };
}

class Task {
    @log
    runTask(arg: any): any {
        console.log("runTask invoked, args: " + arg);
        return "finished";
    }
}

let task = new Task();
let result = task.runTask("learn ts");
console.log("result: " + result);
```

### 4.参数装饰器

接收三个参数- 被装饰的类target 和 方法名key 和 方法中参数的索引值parameterIndex
```js
function Log(target: Function, key: string, parameterIndex: number) {
  let functionLogged = key || target.prototype.constructor.name;
  console.log(`The parameter in position ${parameterIndex} at ${functionLogged} has
	been decorated`);
}

class Greeter {
  greeting: string;
  constructor(@Log phrase: string) {
	this.greeting = phrase; 
  }
}
```

待办任务：
xiaoman的ts
8-class和9-抽象类
14-symbol类型和15-迭代器和生成器
26-实战TS编写发布订阅模式
27-TS进阶用法proxy & Reflect
28-TS进阶用法Partial & Pick
29-TS进阶用法Record & Readonly
30-TS进阶用法infer
31-infer 类型提取
32-infer 递归


## 参考

1. [深入理解 TypeScript](https://jkchao.github.io/typescript-book-chinese/project/compilationContext.html#tsconfig-json)
2. [来玩 TypeScript 啊，机都给你开好了！](https://www.zhihu.com/column/c_206498766)
