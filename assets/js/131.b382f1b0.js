(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{648:function(t,s,e){"use strict";e.r(s);var a=e(60),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("双向数据绑定是Vue的三要素之一，Vue三要素包括：")]),t._v(" "),e("ol",[e("li",[t._v("数据响应式: 例如如何监听数据变化，其中的实现方法就是我们提到的双向数据绑定")]),t._v(" "),e("li",[t._v("模板引擎解析: 如何解析模板")]),t._v(" "),e("li",[t._v("页面渲染: Vue如何将监听到的数据变化和解析后的HTML进行渲染")])]),t._v(" "),e("p",[t._v("可以实现双向数据绑定的方法有很多：")]),t._v(" "),e("ul",[e("li",[t._v("KnockoutJS基于观察者模式的双向数据绑定")]),t._v(" "),e("li",[t._v("Ember基于数据模型的双向绑定")]),t._v(" "),e("li",[t._v("Angular基于脏检查的双向绑定")]),t._v(" "),e("li",[t._v("Vue中基于数据劫持的双向数据绑定")])]),t._v(" "),e("p",[t._v("这里主要来说一下面试中常见的基于数据劫持的双向数据绑定。")]),t._v(" "),e("p",[t._v("常见的基于数据劫持的双向绑定有两种实现，一个是目前Vue在用的Object.defineProperty，另一个是ES2015中新增的Proxy，而Vue3.0版本后加入Proxy从而代替Object.defineProperty，通过本文你也可以知道为什么Vue未来会选择Proxy。")]),t._v(" "),e("p",[t._v("严格来讲Proxy应该被称为『代理』而非『劫持』，不过由于作用有很多相似之处，我们在下文中就不再做区分，统一叫『劫持』。")]),t._v(" "),e("h2",{attrs:{id:"object-defineproperty缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty缺点"}},[t._v("#")]),t._v(" Object.defineProperty缺点")]),t._v(" "),e("ol",[e("li",[t._v("无法直接监听对象，需要循环递归遍历监听对象的属性")]),t._v(" "),e("li",[t._v("无法监听对象新增加的属性")]),t._v(" "),e("li",[t._v("无法监听数组的push/shift/pop等方法")])]),t._v(" "),e("h3",{attrs:{id:"对于对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对于对象"}},[t._v("#")]),t._v(" 对于对象")]),t._v(" "),e("p",[t._v("Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。例如：")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" vm "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vue")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("data")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("a")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `vm.a` 是响应式的")]),t._v("\n\nvm"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("b "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `vm.b` 是非响应式的")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br")])]),e("p",[t._v("对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property。例如，对于：")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[t._v("Vue"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vm"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("someObject"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'b'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("p",[t._v("您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：")]),t._v(" "),e("div",{staticClass:"language-js line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("$set")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("someObject"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'b'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("h3",{attrs:{id:"异步更新队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步更新队列"}},[t._v("#")]),t._v(" 异步更新队列")]),t._v(" "),e("p",[t._v("Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。")]),t._v(" "),e("h2",{attrs:{id:"基于es6的proxy实现数据劫持-即双向绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于es6的proxy实现数据劫持-即双向绑定"}},[t._v("#")]),t._v(" 基于ES6的proxy实现数据劫持(即双向绑定)")]),t._v(" "),e("p",[t._v("Proxy优势：")]),t._v(" "),e("ol",[e("li",[t._v("可以直接监听对象而非对象属性")]),t._v(" "),e("li",[t._v("可以直接监听数组的变化")]),t._v(" "),e("li",[t._v("Proxy有多达13种拦截方法，不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。")]),t._v(" "),e("li",[t._v("Proxy返回的是一个新对象，我们可以只操作新的对象达到目的，而Object.defineProperty只能遍历对象属性直接修改。")])]),t._v(" "),e("h2",{attrs:{id:"参考文档"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考文档"}},[t._v("#")]),t._v(" 参考文档")]),t._v(" "),e("ol",[e("li",[e("a",{attrs:{href:"https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf",target:"_blank",rel:"noopener noreferrer"}},[t._v("实现双向绑定Proxy比defineproperty优劣如何?"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=r.exports}}]);